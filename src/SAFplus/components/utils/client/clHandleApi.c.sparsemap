/*
 * Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
 * 
 * The source code for  this program is not published  or otherwise 
 * divested of  its trade secrets, irrespective  of  what  has been 
 * deposited with the U.S. Copyright office.
 * 
 * This program is  free software; you can redistribute it and / or
 * modify  it under  the  terms  of  the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * 
 * This program is distributed in the  hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * You  should  have  received  a  copy of  the  GNU General Public
 * License along  with  this program. If  not,  write  to  the 
 * Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
/*
 * Build: 4.2.0
 */
/*******************************************************************************
 * ModuleName  : utils
 * File        : clHandleApi.c
 *******************************************************************************/

/*******************************************************************************
 * Description :
 * This is the implementation of a client side handle management service.
 *
 * Part of this code was inspired by the openais code, hence I retained
 * the copyright below.
 *****************************************************************************/

/*
 * Copyright (c) 2002-2004 MontaVista Software, Inc.
 *
 * All rights reserved.
 *
 * Author: Steven Dake (sdake@mvista.com)
 *
 * This software licensed under BSD license, the text of which follows:
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * - Neither the name of the MontaVista Software, Inc. nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <string.h>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>

#include <clCommon.h>
#include <clCommonErrors.h>
#include <clDebugApi.h>
#include <clDbg.h>
#include <clOsalApi.h>
#include <clLogApi.h>

#include <clHandleApi.h>
#include <clHandleErrors.h>
#include <ipi/clHandleIpi.h>

#define nullChkRet(ptr) clDbgIfNullReturn(ptr, CL_CID_HANDLE);

#define CL_HDL_NUM_HDLS_BUNCH           32
#define CL_HDL_NUM_HDLS_BUNCH_MASK      (CL_HDL_NUM_HDLS_BUNCH-1)
#define CL_HDL_INVALID_COOKIE           0xDEADBEEF


/* Reserve the top 16 bits to indicate the DB handle */
#define CL_HDL_NODE_MASK    0xFFFF000000000000ULL /* (((1<<16)-1)<<(63-16)) */
#define CL_HDL_DB_MASK      0x0000FFFF00000000ULL

/* macros to manipulate handles */
#define CL_HDL_NODE(hdl) ((((ClUint64T)hdl)&CL_HDL_NODE_MASK)>>48)
#define CL_HDL_DB(hdl) ((((ClUint64T)hdl)&CL_HDL_DB_MASK)>>32)
#define CL_HDL_MAKE(node,dbid, idx) (((ClHandleT) idx) | (((ClHandleT) node)<<48) | (((ClHandleT) dbid)<<32))


const ClCharT  *CL_HDL_VALID_DB     = "clHandleDBValid";
static ClUint32T handleDbId         = 1;


#define CL_HDL_AREA           "HDL"
#define CL_HDL_CTX_CREATE     "HLC"
#define CL_HDL_CTX_DBCREATE   "HBC"
#define CL_HDL_CTX_CHECKOUT   "HCO"
#define CL_HDL_CTX_CHECKIN    "HCI"
#define CL_HDL_CTX_DESTROY    "HLD"
#define CL_HDL_CTX_DBDESTROY  "HBD"

#define hdlValidityChk(hdl,hdbp) \
    do                                      \
    {                                       \
        if( CL_HDL_DB(hdl) != hdbp->id)                  \
        {                                   \
            clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED, "Handle does not belong to this handle database"); \
            return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);    \
        }                                                  \
    }while(0)                                                                      \


#define hdlDbValidityChk(hdbp)                                          \
    do                                                                  \
    {                                                                   \
        if( NULL == hdbp )                                              \
        {                                                               \
            clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED,        \
                              "Passed NULL for database handle");       \
            return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);                 \
        }                                                               \
        if( *((ClCharT **) hdbp) != CL_HDL_VALID_DB )                   \
        {                                                               \
            if( *((ClCharT **) hdbp) == (ClCharT *) CL_HDL_INVALID_COOKIE ) \
            {                                                           \
                clLogConsoleError(CL_HDL_AREA, CL_LOG_CONTEXT_UNSPECIFIED, \
                                  "Handle database [%p] has already been destroyed", \
                                  (ClPtrT) hdbp);                       \
                return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);             \
            }                                                           \
            clLogConsoleCritical(CL_HDL_AREA, CL_LOG_CONTEXT_UNSPECIFIED, \
                                 "This DB handle [%p] is corrupt, MD check failed", (ClPtrT) hdbp); \
            return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);                 \
        }                                                               \
    }while(0)
            
/******************************************************************************
 * LOCAL TYPES AND VARIABLES
 *****************************************************************************/

typedef enum handle_state
{
	HANDLE_STATE_EMPTY = 0,      /* Value of 0 must indicate unused state */
	HANDLE_STATE_USED,
	HANDLE_STATE_PENDINGREMOVAL
} ClHdlStateT;


#define  HANDLE_ALLOC_FLAG 1  

#define __ALIGN(x, a)  ( ( (x) + (a) - 1) & ~((a) - 1) )
#define __BITS_TO_BYTES(bits) (__ALIGN(bits, 8) >> 3 )
#define __BITS_TO_WORDS(bits)  (__ALIGN(__BITS_TO_BYTES(bits), 4) >> 2 )
#define __BIT_SET(map, bit) ( (map)[ (bit) >> 5 ]  |= (1 << ( (bit) & 31 ) ) )
#define __BIT_CLEAR(map, bit) ( (map)[ (bit) >> 5 ] &= ~( 1 << ( (bit) & 31 ) ) )
#define __BIT_TEST(map, bit)  (!!( (map)[ (bit) >> 5 ] & ( 1 << ( (bit) & 31 ) ) ) )

typedef struct handle_entry {
    ClHandleT    handle;
	ClHdlStateT  state;
    void         *instance;
	ClUint32T    ref_count;
    ClCharT      flags;
} ClHdlEntryT;

/* Struct for handle database */
typedef struct handle_database
{
    void                *pValidDb;      /* Required for DB handle validity check */
	pthread_mutex_t     mutex;          /* Mutex to guard database manip. */
	ClHdlEntryT         *handles;        /* Linear array of handles */
    ClUint32T           *sparse_map;    /* sparse map of handles to their indexes for faster lookups*/
    ClUint32T           sparse_max_index;      /* max index for sparse map storage */
    ClUint32T           *free_list_index;  /* list of recycled free list indexes */
    ClUint32T           num_free_indexes;
    ClUint32T           num_free_indexes_max;
    ClUint32T           *free_list_map;
    ClUint32T           free_list_mapwords;
	ClUint32T           n_handles;      /* Number of handles in the database */
	ClUint32T           n_handles_used; /* Number of handles in use */
    ClUint32T           id;             /* Handle database id */
	void (*handle_instance_destructor) (void *); /* Callback to free a handle */
    ClBoolT             destroyFlag;
} ClHdlDatabaseT;

/******************************************************************************
 * API FUNCTIONS
 *****************************************************************************/

/*
 * Creates a new handle database.  User is responsible to cleanup and free
 * database.
 */
ClRcT
clHandleDatabaseCreate(
    void                    (*destructor)(void*),
    ClHandleDatabaseHandleT  *databaseHandle)
{
    ClHdlDatabaseT *hdbp = NULL;
    
    nullChkRet(databaseHandle);

    hdbp = (ClHdlDatabaseT*) clHeapCalloc(1, sizeof(ClHdlDatabaseT));
    if (NULL == hdbp)
    {
        clLogConsoleError(CL_HDL_AREA, CL_HDL_CTX_DBCREATE, 
                          "Memory allocation failed");
        return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
    }
    
    (void)pthread_mutex_init(&hdbp->mutex, NULL); /* This always returns 0 */
    if (destructor != NULL)
    {
        hdbp->handle_instance_destructor = destructor;
    }
    hdbp->pValidDb = (void *) CL_HDL_VALID_DB;
    hdbp->destroyFlag = CL_FALSE;
    hdbp->id = handleDbId++;
    hdbp->sparse_map = malloc(sizeof(*hdbp->sparse_map) * CL_HDL_NUM_HDLS_BUNCH);
    hdbp->free_list_map = calloc(CL_HDL_NUM_HDLS_BUNCH, sizeof(*hdbp->free_list_map));
    CL_ASSERT(hdbp->sparse_map && hdbp->free_list_map);
    hdbp->sparse_max_index = CL_HDL_NUM_HDLS_BUNCH;
    hdbp->free_list_mapwords = __BITS_TO_WORDS(CL_HDL_NUM_HDLS_BUNCH);
    hdbp->free_list_index = NULL;
    /*
     * Database handle is obtained from memory address here. This is OK,
     * since (1) handle type is larger or same size as address, (2) the
     * use of handle is limited to one process.
     */
    *databaseHandle = hdbp;
#if 0
    clLogTrace(CL_HDL_AREA, CL_HDL_CTX_DBCREATE, 
             "Database [%p] has been created", (ClPtrT) hdbp);
#endif
    clDbgResourceNotify(clDbgHandleGroupResource, clDbgAllocate, 0, hdbp, ("Handle database %p allocated", (ClPtrT) hdbp));
    
    return CL_OK;
}

/*
 * Frees up the handle database specified by databaseHandle.  If the handle
 * database is empty, it frees up the database immediately.  Otherwise,
 * it will mark the database for deletion and free it when the last entry
 * is deleted.
 */
ClRcT
clHandleDatabaseDestroy(ClHandleDatabaseHandleT databaseHandle)
{
    ClHdlDatabaseT *hdbp   = (ClHdlDatabaseT*)databaseHandle;
    ClRcT          ec      = CL_OK;
    ClUint32T i;
    ClHandleT tempHandle = 0; 

    hdlDbValidityChk(hdbp);
    
    ec = pthread_mutex_lock(&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }
    if(hdbp->destroyFlag == CL_TRUE)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "DESTROY", "Handle database [%p] destroy already in progress",
                          (void*)hdbp);
        return CL_HANDLE_RC(CL_ERR_INUSE);
    }

    clDbgResourceNotify(clDbgHandleGroupResource, clDbgRelease, 0, hdbp, ("Handle database %p released", (ClPtrT) hdbp));
    /*
     * Go thru the list of handles and delete everything, if they have not
     * been cleaned up properly, through warning message and destroy the
     * database
     */
    hdbp->destroyFlag = CL_TRUE;
    if (hdbp->n_handles_used > 0) /* database is not empty */
    {
        for(i = 0; i < hdbp->n_handles_used; ++i)
        {
            if( hdbp->handles[i].state != HANDLE_STATE_EMPTY )
            {
                /*
                 * explicitly making '0' for smooth removal of handles 
                 */
                tempHandle = hdbp->handles[i].handle;
                hdbp->handles[i].ref_count = 1;
                hdbp->handles[i].state     = HANDLE_STATE_PENDINGREMOVAL;
                ec = pthread_mutex_unlock(&hdbp->mutex);
                if( ec != 0 )
                {
                    /* Who cares about the error code, during shut down */
                    goto free_exit;          
                }
                clLogWarning(CL_HDL_AREA, CL_HDL_CTX_DBDESTROY, 
                             "Handle [%p:%#llx] has not been cleaned, destroying...",
                             (ClPtrT) hdbp, tempHandle);
                clHandleCheckin(databaseHandle, tempHandle);
                ec = pthread_mutex_lock(&hdbp->mutex);
                if( ec != 0 )
                {
                    goto free_exit;
                }
            }
        }
    }
    /* Explicitly not checking the error code */    
    pthread_mutex_unlock(&hdbp->mutex);
    free_exit:    
    if( NULL != hdbp->handles )
    {
        free(hdbp->handles); 
    }
    if(hdbp->sparse_map) 
    {
        free(hdbp->sparse_map);
    }
    if(hdbp->free_list_map)
    {
        free(hdbp->free_list_map);
    }
    if(hdbp->free_list_index)
    {
        free(hdbp->free_list_index);
    }
    hdbp->pValidDb = (void *) CL_HDL_INVALID_COOKIE; 
    clHeapFree(hdbp);
    return CL_OK;
}

static __inline__ ClRcT 
__handleMapCheck(ClHdlDatabaseT *hdbp, ClUint32T index, ClHandleT handle, ClBoolT verbose)
{
    if(index >= hdbp->sparse_max_index) return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    ClUint32T slotIndex = hdbp->sparse_map[index];
    ClHandleT slotHandle = 0;
    ClUint32T slotHandleIndex = 0;
    if(slotIndex < hdbp->n_handles_used)
    {
        slotHandle = hdbp->handles[slotIndex].handle;
        slotHandleIndex = CL_HDL_IDX(slotHandle)-1;
        if(handle && slotHandle != handle)
        {
            /*
             * Should be a node mismatch at the most.
             * Uncomment if you want to enable DB id match for handles
             */
            /*
              if(CL_HDL_DB(slotHandle) != CL_HDL_DB(handle))
                  return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
            */
        }
        if(slotHandleIndex == index) return CL_OK;
    }
    if(verbose)
    {
        clLogConsoleError("SPARSE", "CHECK", "Handle [%llx] invalid, index [%d], sparse slot [%d], "
                          "slot [%#llx], [%d]", 
                          handle, index, slotIndex, slotHandle, slotHandleIndex);
    }
    return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
}

static ClRcT
clHandleMapCheckSilent(ClHdlDatabaseT *hdbp, ClUint32T index, ClHandleT handle)
{
    return __handleMapCheck(hdbp, index, handle, CL_FALSE);
}

static ClRcT
clHandleMapCheck(ClHdlDatabaseT *hdbp, ClUint32T index, ClHandleT handle)
{
    return __handleMapCheck(hdbp, index, handle, CL_TRUE);
}

/*
 * Recycle the handle into the sparse map and unmap the last entry into the free list
 */
static void clHandleFreeListAdd(ClHdlDatabaseT *hdbp, ClUint32T index1, ClUint32T index2)
{
    if(hdbp->num_free_indexes >= hdbp->num_free_indexes_max)
    {
        hdbp->free_list_index = realloc(hdbp->free_list_index,
                                        sizeof(*hdbp->free_list_index) *
                                        (hdbp->num_free_indexes + CL_HDL_NUM_HDLS_BUNCH));
        CL_ASSERT(hdbp->free_list_index != NULL);
        hdbp->num_free_indexes_max = hdbp->num_free_indexes + CL_HDL_NUM_HDLS_BUNCH;
    }
    /*
     * Check if index1 slot is already being used with a specific handle that was created
     */
    
    ClUint32T map_words1 = __BITS_TO_WORDS(index1);
    ClUint32T map_words2 = __BITS_TO_WORDS(index2);
    ClUint32T map_words = CL_MAX(map_words1, map_words2);
    ClUint32T cur_map_words = hdbp->free_list_mapwords;
    if(map_words >= cur_map_words)
    {
        hdbp->free_list_mapwords = map_words + CL_HDL_NUM_HDLS_BUNCH;
        hdbp->free_list_map = realloc(hdbp->free_list_map, 
                                      sizeof(*hdbp->free_list_map) * 
                                      hdbp->free_list_mapwords);
        CL_ASSERT(hdbp->free_list_map != NULL);
        memset(hdbp->free_list_map + cur_map_words, 0, 
               sizeof(*hdbp->free_list_map) * (hdbp->free_list_mapwords - cur_map_words));
    }
    if(clHandleMapCheckSilent(hdbp, index1, 0) != CL_OK 
       &&
       !__BIT_TEST(hdbp->free_list_map, index1))
    {
        hdbp->free_list_index[hdbp->num_free_indexes++] = index1;
        __BIT_SET(hdbp->free_list_map, index1);
        clLogConsoleDebug("SPARSE", "CHECK", "Index [%d] added to the free list for handle [%p]",
                          index1, (ClPtrT)hdbp);
    }
    else if(!__BIT_TEST(hdbp->free_list_map, index2))
    {
        hdbp->free_list_index[hdbp->num_free_indexes++] = index2;
        __BIT_SET(hdbp->free_list_map, index2);
        clLogConsoleDebug("SPARSE", "CHECK", "Index [%d] added to the free list for handle [%p]",
                          index2, (ClPtrT)hdbp);
    }
}

static __inline__ ClUint32T clHandleFreeListGet(ClHdlDatabaseT *hdbp)
{
    if(!hdbp->num_free_indexes) return -1;
    /*
     * Find a free index thats also set in the bitmap.
     */
    ClUint32T index = -1;
    while(hdbp->num_free_indexes > 0)
    {
        index = hdbp->free_list_index[--hdbp->num_free_indexes];
        if(__BIT_TEST(hdbp->free_list_map, index)) 
        {
            __BIT_CLEAR(hdbp->free_list_map, index);
            return index;
        }
    }
    return -1;
}

static __inline__ ClInt32T clHandleFreeListClear(ClHdlDatabaseT *hdbp, ClUint32T index)
{
    if(!hdbp->free_list_map) return -1;
    if(__BITS_TO_WORDS(index) > __BITS_TO_WORDS(hdbp->free_list_mapwords)) 
        return -1;
    __BIT_CLEAR(hdbp->free_list_map, index);
    return 0;
}

static ClRcT
handleAdd (ClHandleDatabaseHandleT databaseHandle,  ClUint32T instanceSize, ClHandleT* handle_out)
{
    ClHdlEntryT    *new_handles = NULL;
    ClRcT          rc           = CL_OK;
    ClHdlDatabaseT *hdbp        = (ClHdlDatabaseT*) databaseHandle;
    void *instance = NULL;
    ClUint32T index = 0, handleIndex = 0;
    ClHandleT handle = 0;
    
    nullChkRet(handle_out);
    hdlDbValidityChk(hdbp);

    rc = pthread_mutex_lock (&hdbp->mutex);
    if (rc != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }

    handleIndex = hdbp->n_handles_used;
    index = clHandleFreeListGet(hdbp);
    if(index == -1)
    {
        index = handleIndex;
    }
    if(index >= hdbp->n_handles 
       ||
       handleIndex >= hdbp->n_handles)
    {
        ClUint32T growIndex = CL_MAX(handleIndex, index);
        new_handles = (ClHdlEntryT *) realloc ( hdbp->handles, 
                                                sizeof (ClHdlEntryT) *
                                                (growIndex + CL_HDL_NUM_HDLS_BUNCH));
        if (new_handles == NULL)
        {
            rc = pthread_mutex_unlock (&hdbp->mutex);
            if (rc != 0)
            {
                return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be very bad */
            }
            return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
        }
        memset(new_handles+hdbp->n_handles, 0, sizeof(*new_handles) * 
               (growIndex + CL_HDL_NUM_HDLS_BUNCH - hdbp->n_handles));
        hdbp->handles = new_handles;
        hdbp->n_handles = growIndex + CL_HDL_NUM_HDLS_BUNCH;
    }

    /*
     * Realloc sparse map if required
     */
    if(index >= hdbp->sparse_max_index)
    {
        hdbp->sparse_map = realloc(hdbp->sparse_map, sizeof(*hdbp->sparse_map)
                                   * (index + CL_HDL_NUM_HDLS_BUNCH));
        if(hdbp->sparse_map == NULL)
        {
            pthread_mutex_unlock(&hdbp->mutex);
            return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
        }
        hdbp->sparse_max_index = index + CL_HDL_NUM_HDLS_BUNCH;
    }

    instance = clHeapCalloc(1, instanceSize);
    if(instance == NULL)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
    }
    /*
     * Point of no return.
     */
    hdbp->sparse_map[index] = handleIndex;
    handle = CL_HDL_MAKE(ASP_NODEADDR, hdbp->id, index+1);
    memset(hdbp->handles+handleIndex, 0, sizeof(*hdbp->handles));
    hdbp->handles[handleIndex].state     = HANDLE_STATE_USED;
    hdbp->handles[handleIndex].instance  = instance;
    hdbp->handles[handleIndex].ref_count = 1;
    hdbp->handles[handleIndex].flags     = HANDLE_ALLOC_FLAG;
    hdbp->handles[handleIndex].handle = handle;
    hdbp->n_handles_used++;

    *handle_out = handle;

    clDbgResourceNotify(clDbgHandleResource, clDbgAllocate, hdbp, index+1, 
                        ("Handle [%p:%#x] allocated", (ClPtrT)hdbp, index+1));

    clLogConsoleDebug("SPARSE", "CHECK", "Handle [%llx], index [%d], sparse slot [%d]",
                      handle, index, hdbp->sparse_map[index]);
    pthread_mutex_unlock (&hdbp->mutex);
    return rc;
}

ClRcT
clHandleCreate (
                ClHandleDatabaseHandleT databaseHandle,
                ClInt32T instance_size,
                ClHandleT *handle_out)
{
    ClHdlDatabaseT *hdbp        = (ClHdlDatabaseT*) databaseHandle;

    nullChkRet(handle_out);
    hdlDbValidityChk(hdbp);
  
    return  handleAdd (databaseHandle, instance_size, handle_out);
}

ClRcT
clHandleCreateSpecifiedHandle (
    ClHandleDatabaseHandleT databaseHandle,
	ClInt32T instance_size,
    ClHandleT handle)
{
	void           *instance = NULL;
    ClRcT          rc        = CL_OK;
    ClHdlDatabaseT *hdbp     = (ClHdlDatabaseT*) databaseHandle;
    ClRcT          ec        = CL_OK;
    ClUint32T index = 0, refIndex = 0;

    hdlDbValidityChk(hdbp);
    /* We allow handles to be created that are pointing to some other handle DB and node hdlValidityChk(handle,hdbp); */
    index = CL_HDL_IDX(handle); /* once we've verified it, we only care about the index */

    if (index == CL_HANDLE_INVALID_VALUE)
    {
        clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED, 
                          "Passed handle [%p:%#x] is an invalid handle",
                          (ClPtrT) hdbp, index);
        clDbgPause();
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE); /* 0 no longer allowed */
    }
    /*
     * Decrementing handle to ensure the non-zero handle interface.
     */
    --index;
    refIndex = index;

    ec = pthread_mutex_lock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }
    /*
     * Check if the index is being used in which case, the index has to be changed
     * and handles extended
     */
    if(index < hdbp->n_handles_used 
       &&
       hdbp->handles[index].ref_count != 0)
    {
        index = hdbp->n_handles_used; 
    }

    if(index >= hdbp->n_handles)
    {
        ClUint32T excess_handles = index - hdbp->n_handles + 1;

		ClHdlEntryT *new_handles = (ClHdlEntryT *)realloc (hdbp->handles,
			sizeof (ClHdlEntryT) * (hdbp->n_handles+excess_handles));
		if (new_handles == 0) 
        {
			ec = pthread_mutex_unlock (&hdbp->mutex);
            if (ec != 0)
            {
                return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be very bad */
            }
			return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
		}

        /* 
         * Initialize the excess space. HANDLE_STATE_EMPTY will remain 0 
         * is assumed else need to set the excess entries explicitly in a 
         * loop. 
         */
        memset(&new_handles[hdbp->n_handles], 0, sizeof (ClHdlEntryT) * excess_handles);

        /* Update the values if success */
		hdbp->n_handles += excess_handles;
		hdbp->handles = new_handles;
	}

    /*
     * Check if the specified handle is already in use
     */
    if (clHandleMapCheckSilent(hdbp, refIndex, handle) == CL_OK)
    {
        rc = CL_HANDLE_RC(CL_ERR_ALREADY_EXIST);
        goto error_exit;
    }

    if(refIndex >= hdbp->sparse_max_index)
    {
        hdbp->sparse_map = realloc(hdbp->sparse_map, 
                                   sizeof(*hdbp->sparse_map) *
                                   (refIndex + CL_HDL_NUM_HDLS_BUNCH));
        if(hdbp->sparse_map == NULL)
        {
            pthread_mutex_unlock(&hdbp->mutex);
            return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
        }
        hdbp->sparse_max_index = refIndex + CL_HDL_NUM_HDLS_BUNCH;
    }

	instance = clHeapCalloc (1, instance_size);
	if (instance == 0) {
		rc = CL_HANDLE_RC(CL_ERR_NO_MEMORY);
        goto error_exit;
	}
    /*
     * Invalidate the free list index for this slot to avoid re-use
     */
    clHandleFreeListClear(hdbp, refIndex);
    /*
     * Point of no return. Update sparse map
     */
    hdbp->sparse_map[refIndex] = index;

	hdbp->handles[index].state = HANDLE_STATE_USED;
	hdbp->handles[index].instance = instance;
	hdbp->handles[index].ref_count = 1;
    hdbp->handles[index].handle = handle;
    hdbp->handles[index].flags = HANDLE_ALLOC_FLAG;

    clDbgResourceNotify(clDbgHandleResource, clDbgAllocate, hdbp, refIndex+1, 
                        ("Specific handle [%p:%#x] allocated", (ClPtrT) hdbp, refIndex+1));

    clLogConsoleDebug("SPARSE", "CHECK", "Handle [%llx], index [%d], sparse slot [%d], used [%d]",
                      handle, refIndex, index, hdbp->n_handles_used);

    if(index >= hdbp->n_handles_used)
    {
        hdbp->n_handles_used = index+1;
    }

error_exit:

	pthread_mutex_unlock (&hdbp->mutex);
	return rc;
}

ClRcT
clHandleMove(
    ClHandleDatabaseHandleT databaseHandle,
    ClHandleT oldHandle,
    ClHandleT newHandle)
{
	void           *instance = NULL;
    ClRcT          rc        = CL_OK;
    ClHdlDatabaseT *hdbp     = (ClHdlDatabaseT*) databaseHandle;
    ClRcT          ec        = CL_OK;
    ClUint32T oldIndex, oldRefIndex, newIndex, newRefIndex;

    hdlDbValidityChk(hdbp);
    /* We allow handles to be created that are pointing to some other handle DB and node hdlValidityChk(handle,hdbp); */
    oldIndex = CL_HDL_IDX(oldHandle); /* once we've verified it, we only care about the index */
    newIndex = CL_HDL_IDX(newHandle);
    
    if (CL_HANDLE_INVALID_VALUE == oldHandle 
        ||
        CL_HANDLE_INVALID_VALUE == newHandle)
    {
        clLogConsoleError("HDL", "MOVE",
                          "Passed [%s] handle is invalid",
                          oldHandle ? "new" : "old");
        clDbgPause();
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE); /* 0 no longer allowed */
    }
    /*
     * Decrementing handle to ensure the non-zero handle interface.
     */
    --oldIndex;
    --newIndex;
    newRefIndex = newIndex;
    oldRefIndex = oldIndex;
    ec = pthread_mutex_lock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }

    if( (rc = clHandleMapCheckSilent(hdbp, oldRefIndex, oldHandle) ) != CL_OK)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        return rc;
    }
    
    oldIndex = hdbp->sparse_map[oldRefIndex];

    if(oldIndex >= hdbp->n_handles)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "MOVE", "Old handle [%#llx] passed is invalid", oldHandle);
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }

    if(hdbp->handles[oldIndex].ref_count != 1)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "MOVE", "Old handle [%#llx] is %s", 
                          oldHandle, hdbp->handles[oldIndex].ref_count < 1 ? "invalid" : "in use");
        return CL_HANDLE_RC(CL_ERR_INVALID_STATE);
    }
    
    /*
     * Check if the new handle is in use
     */
    if(clHandleMapCheckSilent(hdbp, newRefIndex, newHandle) == CL_OK)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "MOVE", "New handle [%#llx] is in use", newHandle);
        return CL_HANDLE_RC(CL_ERR_ALREADY_EXIST);
    }

    instance = hdbp->handles[oldIndex].instance;
    if(!instance)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "MOVE", "Old handle [%#llx] instance is NULL", oldHandle);
        return CL_HANDLE_RC(CL_ERR_INVALID_STATE);
    }

    if(newIndex < hdbp->n_handles_used
       &&
       hdbp->handles[newIndex].ref_count != 0)
    {
        newIndex = hdbp->n_handles_used;
    }

    if(newIndex >= hdbp->n_handles)
    {
        /*
         * Allocating space in Excess of to accomodate the value specified by the user.
         * NOTE: User should ensure that a sane value is supplied for handle.
         */
        ClUint32T excess_handles = newIndex - hdbp->n_handles + 1;

		ClHdlEntryT *new_handles = (ClHdlEntryT *)realloc (hdbp->handles,
                                                           sizeof (ClHdlEntryT) * (hdbp->n_handles+excess_handles));
		if (new_handles == NULL) 
        {
			ec = pthread_mutex_unlock (&hdbp->mutex);
            if (ec != 0)
            {
                return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be very bad */
            }
			return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
		}

        /* 
         * Initialize the excess space. HANDLE_STATE_EMPTY will remain 0 
         * is assumed else need to set the excess entries explicitly in a 
         * loop. 
         */
        memset(&new_handles[hdbp->n_handles], 0, sizeof (ClHdlEntryT) * excess_handles);

        /* Update the values if success */
		hdbp->n_handles += excess_handles;
		hdbp->handles = new_handles;
	}

    if(newRefIndex >= hdbp->sparse_max_index)
    {
        hdbp->sparse_map = realloc(hdbp->sparse_map, 
                                   sizeof(*hdbp->sparse_map) * (newRefIndex + CL_HDL_NUM_HDLS_BUNCH));
        if(hdbp->sparse_map == NULL)
        {
            pthread_mutex_unlock(&hdbp->mutex);
            return CL_HANDLE_RC(CL_ERR_NO_MEMORY);
        }
        hdbp->sparse_max_index = newRefIndex + CL_HDL_NUM_HDLS_BUNCH;
    }

    hdbp->sparse_map[newRefIndex] = newIndex;
    /*
     * Reset the old handle. This would automatically invalidate the sparse map handle
     *
     */
    memset(&hdbp->handles[oldIndex], 0, sizeof(hdbp->handles[oldIndex]));
    clHandleFreeListAdd(hdbp, oldIndex, oldRefIndex); 
    clHandleFreeListClear(hdbp, newRefIndex);

	hdbp->handles[newIndex].state = HANDLE_STATE_USED;
	hdbp->handles[newIndex].instance = instance;
	hdbp->handles[newIndex].ref_count = 1;
    hdbp->handles[newIndex].handle = newHandle;
    clLogConsoleDebug("SPARSE", "CHECK", "Handle [%llx], index [%d], sparse slot [%d], USED [%d]",
                      newHandle, newRefIndex, newIndex, hdbp->n_handles_used);

    if(newIndex >= hdbp->n_handles_used)
    {
        hdbp->n_handles_used = newIndex + 1;
    }

    pthread_mutex_unlock (&hdbp->mutex);
    clDbgResourceNotify(clDbgHandleResource, clDbgAllocate, hdbp, newHandle, 
                        ("Specific handle [%p:%#llX] allocated", (ClPtrT) hdbp, newHandle));

	return rc;
}

static ClRcT clHandleMapDelete(ClHdlDatabaseT *hdbp, 
                               ClUint32T index, ClHandleT handle)
{
    ClRcT rc = CL_OK;
    if( (rc = clHandleMapCheck(hdbp, index, handle) ) != CL_OK)
        return rc;
    if(!hdbp->n_handles_used) return CL_HANDLE_RC(CL_ERR_INVALID_STATE);
    --hdbp->n_handles_used;
    ClHandleT lastSlotHandle = hdbp->handles[hdbp->n_handles_used].handle;
    ClUint32T lastSlotIndex = CL_HDL_IDX(lastSlotHandle);
    ClUint32T currentSlotIndex = hdbp->sparse_map[index];
    if(!lastSlotIndex) 
    {
        /*
         * Could be a potential hole in the used index in which case, just reset
         * the index state to avoid re-use of the handle
         */
        hdbp->handles[currentSlotIndex].state = HANDLE_STATE_EMPTY;
        return CL_OK;
    }
    --lastSlotIndex;
    clLogConsoleDebug("SPARSE", "CHECK", "Delete Handle [%llx], index [%d], sparse slot [%d], "
                      "used [%d], last slot index [%d], last slot handle [%#llx]",
                      handle, index, hdbp->sparse_map[index], 
                      hdbp->n_handles_used, lastSlotIndex, lastSlotHandle);
    hdbp->sparse_map[lastSlotIndex] = currentSlotIndex;
    memcpy(hdbp->handles+currentSlotIndex, hdbp->handles+hdbp->n_handles_used,
           sizeof(*hdbp->handles));
    memset(hdbp->handles+hdbp->n_handles_used, 0, sizeof(*hdbp->handles));
    clHandleFreeListAdd(hdbp, currentSlotIndex, index);
    return CL_OK;
}

ClRcT
clHandleDestroy (
    ClHandleDatabaseHandleT databaseHandle,
    ClHandleT handle)
{
    ClHdlDatabaseT *hdbp = (ClHdlDatabaseT*) databaseHandle;
    ClRcT          ec    = CL_OK;
    ClUint32T index ;

    hdlDbValidityChk(hdbp);
    index = CL_HDL_IDX(handle); /* once we've verified it, we only care about the index */
    
    /*
     * Decrementing handle to ensure the non-zero handle interface.
     */
    if (CL_HANDLE_INVALID_VALUE == index--)
    {
        clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED, 
                          "Passed handle [%p:%#llX] is invalid", (ClPtrT) hdbp, handle);
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE); /* 0 no longer allowed */
    }
    /* Verify this particular handle has been already created */
    if( (NULL == hdbp->handles) || (0 == hdbp->n_handles_used) )
    {
        clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED, 
                          "Invalid attempt to delete the non exiting handle [%p:%#llX]", 
                          (ClPtrT) hdbp, handle);
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }

    ec = pthread_mutex_lock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }
    
    if( (ec = clHandleMapCheckSilent(hdbp, index, handle) ) != CL_OK)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "DESTROY", "Handle [%#llx] is invalid", handle);
        return ec;
    }
    
    index = hdbp->sparse_map[index];

    if (index >= (ClHandleT)hdbp->n_handles)
    {
        ec = pthread_mutex_unlock (&hdbp->mutex);
        if (ec != 0)
        {
            return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
        }
        clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED, 
                          "Passed handle [%p:%#llX] has not been created", 
                          (ClPtrT) hdbp, handle);
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }
    clDbgResourceNotify(clDbgHandleResource, clDbgRelease, hdbp, handle, 
                        ("Handle [%p:%#llX] (state: %d, ref: %d) released", 
                         (ClPtrT)hdbp, handle, hdbp->handles[index].state,hdbp->handles[index].ref_count));

    if (HANDLE_STATE_USED == hdbp->handles[index].state)
    {
        hdbp->handles[index].state = HANDLE_STATE_PENDINGREMOVAL;

        ec = pthread_mutex_unlock (&hdbp->mutex);
        if (ec != 0)
        {
            return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
        }
        ec = clHandleCheckin (databaseHandle, handle);
        return ec;
    }
    else if (HANDLE_STATE_EMPTY == hdbp->handles[index].state)
    {
        ec = CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }
    else if (HANDLE_STATE_PENDINGREMOVAL == hdbp->handles[index].state)
    {
        ec = pthread_mutex_unlock( &hdbp->mutex);
        if( ec != 0 )
        {
            return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
        }
        clLogWarning(CL_HDL_AREA, CL_HDL_CTX_DESTROY,  
                     "Destroy has been called for this handle [%p:%#llX]" 
                     "returning CL_OK", (ClPtrT) hdbp, handle);
        return CL_OK;
    }
    else
    {
        clDbgCodeError(CL_ERR_INVALID_HANDLE, 
                       ("Passed handle [%p:%#llX] doesn't have any proper state,"
                       "corrupted code", (ClPtrT) hdbp, handle));
        /*
         * Invalid state - this musn't happen!
         */
    }
    if(pthread_mutex_unlock (&hdbp->mutex) != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
    }

#if 0
    clLogTrace(CL_HDL_AREA, CL_HDL_CTX_DESTROY, 
               "Handle [%p:%#llX] has been deleted successfully", 
               (ClPtrT) hdbp, handle);
#endif
    return ec;
}


ClRcT
clHandleCheckout(
                 ClHandleDatabaseHandleT databaseHandle,
                 ClHandleT               handle,
                 void                    **instance)
{ 
	ClRcT           rc    = CL_OK;
    ClHdlDatabaseT  *hdbp = (ClHdlDatabaseT*)databaseHandle;
    ClHdlStateT     state = 0;
    ClRcT           ec    = CL_OK;
    ClUint32T index;

    hdlDbValidityChk(hdbp);
    /* sometimes people want to create the same handle across multiple nodes hdlValidityChk(handle,hdbp); */
    index = CL_HDL_IDX(handle); /* once we've verified it, we only care about the index */
    nullChkRet(instance);
    /*
     * Decrementing handle to ensure the non-zero handle interface.
     */
    if (CL_HANDLE_INVALID_VALUE == index--)
    {
        clDbgCodeError(CL_HANDLE_RC(CL_ERR_INVALID_HANDLE), ("Passed Invalid Handle [0x0]"));
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE); /* 0 no longer allowed */
    }

    ec = pthread_mutex_lock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }
    
    if( (ec = clHandleMapCheckSilent(hdbp, index, handle)) != CL_OK)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "CHECKOUT", "Handle [%#llx] is invalid", handle);
        return ec;
    }

    index = hdbp->sparse_map[index];

    if (index >= (ClHandleT)hdbp->n_handles)
    {
        rc = CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
        pthread_mutex_unlock(&hdbp->mutex);
        clDbgCodeError(rc, ("Passed Invalid Handle [%p:%#x]", (ClPtrT) hdbp, index+1));
        return rc;
    }
    
    if ( ( state = hdbp->handles[index].state ) != HANDLE_STATE_USED)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        if (state == HANDLE_STATE_EMPTY)
        {
            /* In some of our ASP components the assumption made,
             * like checkout handle returns CL_ERR_INVALID_HANDLE 
             * to verify the handle does exist or not.
             * so removing the debug pause
             */
#if 0
            clDbgCodeError(rc, ("Handle [%p:%#x] is not allocated", (ClPtrT)
                                hdbp, (index+1)));
#endif
        }
        else if (state == HANDLE_STATE_PENDINGREMOVAL)
        {
            clDbgCodeError(rc, ("Handle [%p:%#x] is being removed", (ClPtrT)
                                hdbp, (index+1)));
        }
        else
        {
            clDbgCodeError(rc, ("Handle [%p:%#x] invalid state %d", (ClPtrT)
                                hdbp, (index+1), state));
        }

        rc = CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
        clDbgCodeError(rc, ("Handle [%p:%#x] is invalid", (ClPtrT) hdbp, (index+1)));
        return rc;
    }

    *instance = hdbp->handles[index].instance;

    hdbp->handles[index].ref_count += 1;

    ec = pthread_mutex_unlock (&hdbp->mutex);
    if (ec != 0)
    {
        clDbgCodeError(CL_HANDLE_RC(CL_ERR_MUTEX_ERROR), ("Mutex unlock failed errno %d", errno));
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
    }
#if 0
    clLogTrace(CL_HDL_AREA, CL_HDL_CTX_CHECKOUT, 
               "Checked out handle [%p:%#x]", (ClPtrT) hdbp, (index + 1));
#endif
    return rc;
}

ClRcT
clHandleCheckin(
                ClHandleDatabaseHandleT databaseHandle,
                ClHandleT handle)
{
    ClRcT          rc        = CL_OK;
    void           *instance = NULL;
    ClHdlDatabaseT *hdbp     = (ClHdlDatabaseT*) databaseHandle;
    ClRcT          ec        = CL_OK;
    ClInt32T       refcount  = 0;
    ClUint32T index, refIndex;

    hdlDbValidityChk(hdbp);
    /* sometimes people want to create the same handle across multiple nodes hdlValidityChk(handle,hdbp); */
    index = CL_HDL_IDX(handle); /* once we've verified it, we only care about the index */
    /*
     * Decrementing handle to ensure the non-zero handle interface.
     */
    if (CL_HANDLE_INVALID_VALUE == index--)
    {
        clLogConsoleError(CL_HDL_AREA, CL_HDL_CTX_CHECKIN, 
                          "Passed handle [%p:%#llX] is invalid", (ClPtrT) hdbp, handle);
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE); /* 0 no longer allowed */
    }

    refIndex = index;

    ec = pthread_mutex_lock(&hdbp->mutex);
    if (ec != 0)
    {
        int err = errno;
        clDbgCodeError(clErr, ("Handle database mutex lock failed error: %s (%d)", strerror(err), err) );
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }

    if( ( ec = clHandleMapCheckSilent(hdbp, refIndex, handle) ) != CL_OK)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "CHECKIN", "Handle [%#llx] is invalid", handle);
        return ec;
    }

    index = hdbp->sparse_map[refIndex];

    if (index >= (ClHandleT)hdbp->n_handles)
    {
        pthread_mutex_unlock( &hdbp->mutex);
        clLogConsoleError(CL_HDL_AREA, CL_HDL_CTX_CHECKIN, 
                          "Passed handle [%p:%#llX] is invalid handle", (ClPtrT) hdbp, handle);
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }
    refcount = hdbp->handles[index].ref_count;
    if( (--refcount <= 0) && (hdbp->handles[index].state != HANDLE_STATE_PENDINGREMOVAL) )
    {
        pthread_mutex_unlock( &hdbp->mutex);
        clLogConsoleError(CL_HDL_AREA, CL_HDL_CTX_CHECKIN,  
                          "There is no balance between checkout, checkin for handle [%p:%#llX]", 
                          (ClPtrT) hdbp, handle);
        return CL_HANDLE_RC(CL_ERR_INVALID_STATE);
    }

    CL_ASSERT(hdbp->handles[index].ref_count > 0); 
    hdbp->handles[index].ref_count -= 1;

    if (hdbp->handles[index].ref_count == 0)
    {
        instance = hdbp->handles[index].instance;
        if (hdbp->handle_instance_destructor != NULL)
        {
            hdbp->handle_instance_destructor(instance);
        }
        if (hdbp->handles[index].flags & HANDLE_ALLOC_FLAG)  /* Clean up the handle if we allocated it */
            clHeapFree(instance);
        /*
         * IF handle db is being destroyed, then no need to unmap from sparse map
         */
        if(!hdbp->destroyFlag)
        {
            /*
             * Recycle the reference
             */
            rc = clHandleMapDelete(hdbp, refIndex, handle);
        }
    }

    ec = pthread_mutex_unlock(&hdbp->mutex);
    if (ec != 0)
    {
        int err = errno;
        clDbgCodeError(clErr, ("Handle database mutex unlock failed error: %s (%d)", strerror(err), err) );
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
    }
    /* This check to avoid recursive call from LogClient */
    if( refcount > 0 )
    {
#if 0
        clLogTrace(CL_HDL_AREA, CL_HDL_CTX_CHECKIN, 
                   "Checkin for handle [%p:%#llX]", 
                   (ClPtrT) hdbp, handle);
#endif
    }

    return rc;
}

/*
 * The following API was added to walk through the existing handle database
 * and execute the user specified callback for each handle in use.
 */
ClRcT
clHandleWalk (ClHandleDatabaseHandleT databaseHandle,
	ClHandleDbWalkCallbackT fpUserWalkCallback,
    void *pCookie)
{
	ClUint32T handles_used = 0, i;
    ClHdlDatabaseT *hdbp   = (ClHdlDatabaseT*)databaseHandle;
    ClHandleT *pHandles = NULL;
    ClRcT          ec      = CL_OK;
    ClRcT          rc      = CL_OK;

    hdlDbValidityChk(hdbp);
    if (NULL == fpUserWalkCallback)
    {
        clLogConsoleError("HDL", CL_LOG_CONTEXT_UNSPECIFIED, "fpUserWalkCallback is NULL");
        return CL_HANDLE_RC(CL_ERR_NULL_POINTER);
    }

    ec = pthread_mutex_lock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }

    pHandles = calloc(hdbp->n_handles_used, sizeof(*pHandles));
    CL_ASSERT(pHandles != NULL);

    for(i = 0; i < hdbp->n_handles_used; ++i)
    {
        if(hdbp->handles[i].state != HANDLE_STATE_USED)
            continue;
        pHandles[handles_used++] = hdbp->handles[i].handle;
    }

    for (i = 0; i < handles_used; ++i)
    {        
        /*
         * Unlock the database since the user needs to checkout the
         * handle in the callback.
         */
        ec = pthread_mutex_unlock (&hdbp->mutex);
        if (ec != 0)
        {
            rc = CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* Disastrous */
            goto out_free;
        }
        rc = fpUserWalkCallback(databaseHandle, pHandles[i], pCookie);
        if(rc != CL_OK) 
        {
            goto out_free;  /* Already unlocked */
        }

        /*
         * Lock the database again to test check remaining handles.
         */
        ec = pthread_mutex_lock (&hdbp->mutex);
        if (ec != 0)
        {
            rc = CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* Disastrous */
            goto out_free;
        }
    }

    ec = pthread_mutex_unlock (&hdbp->mutex);
    if (ec != 0)
    {
        rc = CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
    }

    out_free:
    if(pHandles) free(pHandles);
    return rc;
}

/*
 * The API returns CL_ERR_INVALID_HANDLE if the handle is not valid.
 */ 
ClRcT
clHandleValidate (
    ClHandleDatabaseHandleT databaseHandle,
    ClHandleT handle)
{
    ClHdlDatabaseT *hdbp = (ClHdlDatabaseT*)databaseHandle;
    int            ec    = 0;
    ClUint32T index;

    hdlDbValidityChk(hdbp);
    /* sometimes people want to create the same handle across multiple nodes hdlValidityChk(handle,hdbp); */
    index = CL_HDL_IDX(handle); /* once we've verified it, we only care about the index */
    /*
     * Decrementing handle to ensure the non-zero handle interface.
     */
    if (CL_HANDLE_INVALID_VALUE == index--)
    {
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE); /* 0 no longer allowed */
    }

	ec = pthread_mutex_lock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR);
    }
    
    if( (ec = clHandleMapCheckSilent(hdbp, index, handle) ) != CL_OK)
    {
        pthread_mutex_unlock(&hdbp->mutex);
        clLogConsoleError("HDL", "VALIDATE", "Handle [%#llx] is invalid", handle);
        return ec;
    }

    index = hdbp->sparse_map[index];

    if (index >= (ClHandleT)hdbp->n_handles)
    {
        ec = pthread_mutex_unlock (&hdbp->mutex);
        if (ec != 0)
        {
            return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
        }
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }

    if (HANDLE_STATE_USED != hdbp->handles[index].state )
    {
        ec = pthread_mutex_unlock (&hdbp->mutex);
        if (ec != 0)
        {
            return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
        }
        return CL_HANDLE_RC(CL_ERR_INVALID_HANDLE);
    }

	ec = pthread_mutex_unlock (&hdbp->mutex);
    if (ec != 0)
    {
        return CL_HANDLE_RC(CL_ERR_MUTEX_ERROR); /* This can be devastating */
    }

	return CL_OK;
}
